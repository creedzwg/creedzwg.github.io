import projectConfig from '/pagic.config.js';
export default {
    config: { "root": "/", ...projectConfig, branch: 'main' },
    'pagePath': "posts/java8_new_feature.md",
    'layoutPath': "posts/_layout.tsx",
    'outputPath': "posts/java8_new_feature.html",
    'title': "java8 新特性教程",
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h1>java8 新特性教程</h1>\n<blockquote>\n<p>代码地址:<a href="https://github.com/creedzwg/java8_action.git">https://github.com/creedzwg/java8_action.git</a></p>\n</blockquote>\n<h2 id="%E8%AE%B2%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">讲解的新特性<a class="anchor" href="#%E8%AE%B2%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">§</a></h2>\n<ul>\n<li>lambda表达式</li>\n<li>函数式接口</li>\n<li>stream API</li>\n</ul>\n<h2 id="lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">lambda 表达式<a class="anchor" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">§</a></h2>\n<h3 id="%E4%BB%80%E4%B9%88%E6%98%AFlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">什么是lambda表达式<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AFlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">§</a></h3>\n<ul>\n<li>lambda表达式,我们可以把它看做是可传递的匿名函数:它没有名称,但他有参数列表,函数主体,返回类型,还有一个可以抛出的异常列表,它允许把函数作为一个方法的参数进行传递</li>\n</ul>\n<h3 id="lambda-%E7%9A%84%E8%AF%AD%E6%B3%95">lambda 的语法<a class="anchor" href="#lambda-%E7%9A%84%E8%AF%AD%E6%B3%95">§</a></h3>\n<ul>\n<li>(parameters) -&gt; expression</li>\n<li>(parameters) -&gt; {statements;}</li>\n</ul>\n<p><strong>例子:</strong></p>\n<pre class="language-autoit"><code class="language-autoit"> <span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n \n <span class="token punctuation">(</span>Apple a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">150</span>\n \n<span class="token punctuation">(</span>int x<span class="token punctuation">,</span> int y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> {\nSystem<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result:"</span><span class="token punctuation">)</span><span class="token comment">;</span>\nSystem<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token comment">;</span>\n}\n\n<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">42</span>\n\n<span class="token punctuation">(</span>Apple a1<span class="token punctuation">,</span> Apple a2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a1<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a2<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n\n</code></pre>\n<p>Lambda表达式其实是为FunctionalInterface(函数式接口)提供服务的\n函数式接口的定义是接口内只有一个抽象方法,接口现在还可以有默认方法,(即在类没有对方法进行实现时，\n其主体为方法提供默认实现的方法)</p>\n<p>可以用<strong>4个</strong>接口来统一定义所有使用lambada表达式的行为</p>\n<pre class="language-autoit"><code class="language-autoit">\n<span class="token variable">@FunctionalInterface</span>\npublic interface Function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> {\n\n    R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token comment">;</span>\n\n}\n\nFunction 接口<span class="token punctuation">,</span>有一个apply方法<span class="token punctuation">,</span>这表示接受一个参数的类型<span class="token punctuation">,</span>并返回另外一个参数的类型\n\n\n<span class="token variable">@FunctionalInterface</span>\npublic interface Consumer<span class="token operator">&lt;</span>T<span class="token operator">></span> {\n\n\n    void <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token comment">;</span>\n}\n\nConsumer接口<span class="token punctuation">,</span>有一个accept方法<span class="token punctuation">,</span>他接受一个参数<span class="token punctuation">,</span>没有任何返回值<span class="token punctuation">,</span>可以做一些处理工作\n\n<span class="token variable">@FunctionalInterface</span>\npublic interface Predicate<span class="token operator">&lt;</span>T<span class="token operator">></span> {\n\n\n    boolean <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token comment">;</span>\n}\n\nPredicate接口<span class="token punctuation">,</span>判断接口<span class="token punctuation">,</span>有一个test方法<span class="token punctuation">,</span>接受一个参数<span class="token punctuation">,</span>返回boolean值\n\n<span class="token variable">@FunctionalInterface</span>\npublic interface Supplier<span class="token operator">&lt;</span>T<span class="token operator">></span> {\n\n    T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\n}\n\nSupplier接口 <span class="token punctuation">,</span>提供者接口<span class="token punctuation">,</span>有一个get方法<span class="token punctuation">,</span>无参数<span class="token punctuation">,</span>有返回值\n\n\n\n\n</code></pre>\n<p>这4个接口只是4个基本接口,还会有许多函数式接口对这些进行扩展,变种,就不详细一一介绍了</p>\n<h3 id="%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%BF%AB%E6%8D%B7%E5%86%99%E6%B3%95"><strong>方法引用,Lambda表达式的另外一种快捷写法</strong><a class="anchor" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%BF%AB%E6%8D%B7%E5%86%99%E6%B3%95">§</a></h3>\n<ul>\n<li>方法引用让你可以重复的使用现有的方法定义,并像lambda一样传递它们,在某些情况下比起lambda表达式,它们似乎更易读,感觉也更自然\n-方法引用可以被看做仅仅调用特定方法的Lambda的一种快捷方式,换句话说,方法引用就是对Lambda表达式的一种简便写法,使用方法引用可能会提高代码的可读性</li>\n</ul>\n<h5 id="%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">方法引用的工作方式<a class="anchor" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">§</a></h5>\n<ul>\n<li>当你需要使用方法引用的时候,目标引用放在分隔符::前,方法的名称放在后面。例如Apple:getWeight 就是引用了Apple类中定义的方法getWeight ,这个就是 (Apple a) -&gt; a.getWeight()的快捷写法,可以把方法引用看做是仅仅针对涉及单一方法的Lambda的语法糖,因为你表达同样的事情要写的代码就更少了。</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit"><span class="token punctuation">(</span>Apple a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                   Apple<span class="token punctuation">:</span><span class="token punctuation">:</span>getWeight\n<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dumpStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>dumpStack\n<span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>                 String<span class="token punctuation">:</span><span class="token punctuation">:</span>substring\n<span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">:</span><span class="token punctuation">:</span>println\n</code></pre>\n<p>####方法引用的分类</p>\n<ol>\n<li>指向静态方法的方法引用(例如Integer.parseInt方法,可以写作Integer::parseInt)</li>\n</ol>\n<p>Lambda: (args) -&gt; ClassName.staticMethod(args)\n方法引用: ClassName:: staticMethod</p>\n<ol start="2">\n<li>指向任意类型实例方法的方法引用(例如String 的length 方法， 写作String::length)\n类似于String::length的第二种方法引用的思想就是你在引用一个对象的方法，而这个对象本身是Lambda的一个参数\nLambda: (arg1,rest) -&gt;arg1.instanceMethod(rest)\n方法引用: ClassName::instanceMethod</li>\n<li>指向现有对象的实例方法的方法引用(假设你有一个局部变量a 用来存放 A类型的对象,它有个示例方法getValue,那么就可以写成a::getValue)\n第三种方法引用指的是，你在Lambda中调用一个已经存在的外部对象中的方法\nSupplier<Integer> s =()-&gt;a.getWeight()\nLambda: (args) -&gt;instance.instanceMethod(args)\n方法引用: instance::instanceMethod</li>\n</ol>\n<h4 id="%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90">具体例子<a class="anchor" href="#%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90">§</a></h4>\n<ul>\n<li>对一个字符串的List进行排序,List的sort方法需要一个Comparator实现作为参数,Comparator描述了一个具有(T,T)-&gt;int签名的函数描述符。你可以利用String类的CompareTo方法来定义一个lambda表达式.</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">List<span class="token operator">&lt;</span>String<span class="token operator">></span> str <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token comment">;</span>\nstr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">;</span>\n\n可以修改成str<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span>compareTo<span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8">构造函数引用<a class="anchor" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8">§</a></h4>\n<ul>\n<li>对于一个现有的构造函数,你可以利用它的名称和关键字new 来创建它的一个引用</li>\n</ul>\n<p><code>Supplier&lt;Apple&gt; c1=Apple::new 等价于 Supplier&lt;Apple&gt; c1=()-&gt;new Apple()</code></p>\n<h4 id="lambda%E6%80%BB%E7%BB%93">lambda总结<a class="anchor" href="#lambda%E6%80%BB%E7%BB%93">§</a></h4>\n<ul>\n<li>Lambda表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回\n类型，可能还有一个可以抛出的异常的列表。</li>\n<li>Lambda表达式让你可以简洁地传递代码。</li>\n<li>函数式接口就是仅仅声明了一个抽象方法的接口。</li>\n<li>只有在接受函数式接口的地方才可以使用Lambda表达式。</li>\n<li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式\n作为函数式接口的一个实例。</li>\n<li>Java 8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate\n<T>、Function&lt;T,R&gt;、Supplier<T>、Consumer<T>和BinaryOperator<T>，如表\n3-2所述。</li>\n<li>方法引用让你重复使用现有的方法实现并直接传递它们。</li>\n<li>Comparator、Predicate和Function等函数式接口都有几个可以用来结合Lambda表达\n式的默认方法</li>\n</ul>\n<h3 id="stream-%E6%B5%81">Stream 流<a class="anchor" href="#stream-%E6%B5%81">§</a></h3>\n<h4 id="%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5">流的概念<a class="anchor" href="#%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5">§</a></h4>\n<ul>\n<li>流是java API的新成员,它允许你以声明性方式处理数据集合(通过查询语句来表达,而不是临时编写一个实现),同时可以并行处理,提高处理效率</li>\n<li>Stream 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询。也可以使用Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式</li>\n</ul>\n<h4 id="stream%E7%9A%84%E7%94%A8%E6%B3%95">Stream的用法<a class="anchor" href="#stream%E7%9A%84%E7%94%A8%E6%B3%95">§</a></h4>\n<ul>\n<li>流的使用一般包括三件事:</li>\n</ul>\n<ol>\n<li>一个数据源来执行一个查询,(创建stream)</li>\n<li>一个中间操作链,形成一条流的流水线(中间操作)</li>\n<li>一个终端操作,执行流水线,并能生成结果(终止操作)</li>\n</ol>\n<ul>\n<li>创建流的方式</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit"><span class="token operator">/</span><span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span> 可以通过集合顶级集合Collection的默认<span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>或者parallelStream方法\nList<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token operator">=</span>new ArrayList<span class="token operator">&lt;></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\nStream<span class="token operator">&lt;</span>String<span class="token operator">></span> stream1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\n\n<span class="token operator">/</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">.</span>通过Arrays中的静态方法<span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 获取数组流\nDish<span class="token punctuation">[</span><span class="token punctuation">]</span> dishs<span class="token operator">=</span>new  Dish<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token comment">;</span>\nStream<span class="token operator">&lt;</span>Dish<span class="token operator">></span> stream2 <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>dishs<span class="token punctuation">)</span><span class="token comment">;</span>\n<span class="token operator">/</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">.</span> 通过Stream类中的静态方法<span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nStream<span class="token operator">&lt;</span>String<span class="token operator">></span> stream3 <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token string">"bb"</span><span class="token punctuation">,</span> <span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token comment">;</span>\n<span class="token operator">/</span><span class="token operator">/</span>创建无限流\nStream<span class="token operator">&lt;</span>Integer<span class="token operator">></span> iterate <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">;</span>\niterate<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">:</span><span class="token punctuation">:</span>println<span class="token punctuation">)</span><span class="token comment">;</span>\n\n<span class="token operator">/</span><span class="token operator">/</span>通过Stream的generate方式<span class="token punctuation">,</span>也是无限流\n\nStream<span class="token operator">&lt;</span>Double<span class="token operator">></span> generate <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span>Math<span class="token punctuation">:</span><span class="token punctuation">:</span>random<span class="token punctuation">)</span><span class="token comment">;</span>\ngenerate<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">:</span><span class="token punctuation">:</span>println<span class="token punctuation">)</span><span class="token comment">;</span>\n</code></pre>\n<ul>\n<li>中间操作</li>\n</ul>\n<ol>\n<li>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！\n而在终止操作时一次性全部处理，称为“惰性求值&quot;</li>\n</ol>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>类型</th>\n<th>返回类型</th>\n<th>操作参数</th>\n<th>函数描述符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>filter</td>\n<td>中间</td>\n<td>Stream<T></td>\n<td>Predicate<T></td>\n<td>T -&gt; Boolean</td>\n</tr>\n<tr>\n<td>map</td>\n<td>中间操作</td>\n<td>Stream<R></td>\n<td>Function&lt;T,R&gt;</td>\n<td>T -&gt; R</td>\n</tr>\n<tr>\n<td>limit</td>\n<td>中间操作</td>\n<td>Stream<T></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip</td>\n<td>中间操作</td>\n<td>Stream<T></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sorted</td>\n<td>中间操作</td>\n<td>Stream<T></td>\n<td>Comparator<T></td>\n<td>(T,T) -&gt;Int</td>\n</tr>\n<tr>\n<td>distinct</td>\n<td>中间操作</td>\n<td>Stream<T></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>foreach</td>\n<td>终端</td>\n<td>消费流中的每个元素并对其应用Lambda,操作返回void</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>count</td>\n<td></td>\n<td>终端</td>\n<td>返回流中元素的个数,这一顿操作返回Long</td>\n<td></td>\n</tr>\n<tr>\n<td>collect</td>\n<td></td>\n<td>终端</td>\n<td>把流规约成一个集合,比如List,Map甚至是Integer</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="stream-api-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F">stream API 的操作方式<a class="anchor" href="#stream-api-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F">§</a></h4>\n<h4 id="%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C">中间操作<a class="anchor" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C">§</a></h4>\n<h5 id="%E7%AD%9B%E9%80%89%E5%92%8C%E5%88%87%E7%89%87">筛选和切片<a class="anchor" href="#%E7%AD%9B%E9%80%89%E5%92%8C%E5%88%87%E7%89%87">§</a></h5>\n<p>用predicate,筛选出不同的元素,忽略流中的的头几个元素,获奖流切断至指定长度</p>\n<ul>\n<li>filter方法。该操作会接受一个Predicate谓词（一个返回\nboolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>isVegetarian<span class="token punctuation">)</span>\n</code></pre>\n<ul>\n<li>distinct的方法，它会返回一个元素各异（根据流所生成元素的\nhashCode和equals方法实现）的流</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">;</span>\nnumbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre>\n<ul>\n<li>limit(n)方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递\n给limit。如果流是有序的，则最多会返回前n个元素;也可以用在无序流上，比如源是一个Set。这种情况下，limit的结果不会以任何顺序排列</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>d <span class="token operator">-</span><span class="token operator">></span> d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre>\n<ul>\n<li>skip(n)方法 ,流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一\n个空流。</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>d <span class="token operator">-</span><span class="token operator">></span> d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n</code></pre>\n<h5 id="%E6%98%A0%E5%B0%84"><strong>映射</strong><a class="anchor" href="#%E6%98%A0%E5%B0%84">§</a></h5>\n<p>一个非常常见的数据处理套路就是从某些对象中选择信息。比如在SQL里，你可以从表中选择一列。Stream API也通过map和flatMap方法提供了类似的工具</p>\n<ul>\n<li>map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素</li>\n</ul>\n<p>-flatMap他会接受一个参数作为函数,将流中每个值都换成另一个流,最后再将所有流拼成另外一个流</p>\n<pre class="language-autoit"><code class="language-autoit">menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>getName<span class="token punctuation">)</span>\n\n</code></pre>\n<h5 id="%E6%8E%92%E5%BA%8F">排序<a class="anchor" href="#%E6%8E%92%E5%BA%8F">§</a></h5>\n<ul>\n<li>排序分为自然排序(本身实现Cpmparaable 接口,实现了CompareTo方法)</li>\n<li>定制排序,通过Comparator接口实现</li>\n</ul>\n<h4 id="%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C">终止操作<a class="anchor" href="#%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C">§</a></h4>\n<h5 id="%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8C%B9%E9%85%8D">查找和匹配<a class="anchor" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8C%B9%E9%85%8D">§</a></h5>\n<ul>\n<li>另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性,\nStreamAPI通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的具</li>\n</ul>\n<h5 id="%E6%A3%80%E6%9F%A5predicate%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E8%87%B3%E5%B0%91%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">检查Predicate谓词是否至少匹配一个元素<a class="anchor" href="#%E6%A3%80%E6%9F%A5predicate%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E8%87%B3%E5%B0%91%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">§</a></h5>\n<pre class="language-autoit"><code class="language-autoit">此操作用来查看菜单中是否有素食可以选择\n<span class="token function">if</span><span class="token punctuation">(</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>isVegetarian<span class="token punctuation">)</span><span class="token punctuation">)</span>{\nSystem<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有素食"</span><span class="token punctuation">)</span><span class="token comment">;</span>\n}\nanyMatch方法返回一个boolean，因此是一个终端操作 \n</code></pre>\n<h5 id="%E6%A3%80%E6%9F%A5%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0">检查谓词是否匹配所有元素<a class="anchor" href="#%E6%A3%80%E6%9F%A5%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0">§</a></h5>\n<ul>\n<li>allMatch方法的工作原理和anyMatch类似，但它会看看流中的元素是否都能匹配给定的谓词</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">是否菜单里面所有的菜的热量都小于<span class="token number">1000</span>卡路里\nboolean  status<span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span>d <span class="token operator">-</span><span class="token operator">></span> d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment">;</span>\n</code></pre>\n<h5 id="%E6%A3%80%E6%9F%A5%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E6%B2%A1%E6%9C%89%E5%85%83%E7%B4%A0%E8%B7%9F%E4%BB%96%E5%8C%B9%E9%85%8D">检查谓词是否没有元素跟他匹配<a class="anchor" href="#%E6%A3%80%E6%9F%A5%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E6%B2%A1%E6%9C%89%E5%85%83%E7%B4%A0%E8%B7%9F%E4%BB%96%E5%8C%B9%E9%85%8D">§</a></h5>\n<ul>\n<li>noneMatch()跟allMatch()相反,它可以确保流中没有任何元素与给定的谓词匹配</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">是否菜单里面所有的菜的热量都小于<span class="token number">1000</span>卡路里\nmenu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span>d <span class="token operator">-</span><span class="token operator">></span> d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E6%9F%A5%E6%89%BE%E4%BB%BB%E6%84%8F%E5%85%83%E7%B4%A0">查找任意元素<a class="anchor" href="#%E6%9F%A5%E6%89%BE%E4%BB%BB%E6%84%8F%E5%85%83%E7%B4%A0">§</a></h4>\n<ul>\n<li>findAny方法将返回当前流中的任意元素</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit"> Optional<span class="token operator">&lt;</span>Dish<span class="token operator">></span> dish <span class="token operator">=</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>isVegetarian<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\n\n可以看出<span class="token punctuation">,</span>返回的是一个Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">,</span>他是一个容器类<span class="token punctuation">,</span>代表着一个值存在或者不存在<span class="token punctuation">,</span>\n\n在上面的代码中，findAny可能什么元素都没找到。Java <span class="token number">8</span>的库设计人员引入了Optional<span class="token operator">&lt;</span>T<span class="token operator">></span>，这样就不用返回众所周知容易出问题的<span class="token keyword">null</span>了。\n\n\n</code></pre>\n<h4 id="%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">查找第一个元素<a class="anchor" href="#%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">§</a></h4>\n<ul>\n<li>findFirst方法返回流中的第一个数据</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">Optional<span class="token operator">&lt;</span>Dish<span class="token operator">></span> dish <span class="token operator">=</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>isVegetarian<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\n</code></pre>\n<h4 id="%E8%A7%84%E7%BA%A6">规约<a class="anchor" href="#%E8%A7%84%E7%BA%A6">§</a></h4>\n<ul>\n<li>之前讲的终端操作都是一个boolean或者void ,或者Optional对象,也有使用collect来将\n流中的所有元素组合成一个List,</li>\n<li>使用规约可以把流中的元素组合起来,然后得到一个值。</li>\n</ul>\n<h4 id="%E5%85%83%E7%B4%A0%E6%B1%82%E5%92%8C">元素求和<a class="anchor" href="#%E5%85%83%E7%B4%A0%E6%B1%82%E5%92%8C">§</a></h4>\n<pre class="language-autoit"><code class="language-autoit"><span class="token operator">-</span> reduce\n对传统的数字列表的元素进行求和<span class="token punctuation">,</span>我们可能会这么做\nint sum <span class="token operator">=</span> <span class="token number">0</span><span class="token comment">;</span>\nint<span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token operator">=</span>{<span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span>}<span class="token comment">;</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span>int x <span class="token punctuation">:</span> numbers<span class="token punctuation">)</span> {\nsum <span class="token operator">+=</span> x<span class="token comment">;</span>\n}\nnumbers中的每个元素都用加法运算符反复迭代来得到结果。通过反复使用加法，你把一个\n数字列表归约成了一个数字。这段代码中有两个参数：\n<span class="token number">1</span> 总和变量的初始值，在这里是<span class="token number">0</span>；\n<span class="token number">2</span> 将列表中所有元素结合在一起的操作，在这里是<span class="token operator">+</span>\n\n这种就可以使用reduce操作来灵活完成\nint sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token comment">;</span>\nreduce 接受两个参数\n\n<span class="token number">1</span><span class="token punctuation">.</span> 一个初始值<span class="token punctuation">,</span>这个是<span class="token number">0</span>\n<span class="token number">2</span><span class="token punctuation">.</span> 一个BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span>来将两个元素结合起来产生一个新值，这里我们用的是\nlambda <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b。\n\n首先，<span class="token number">0</span>作为Lambda（a）的第一个参数，从流中获得<span class="token number">4</span>作为第二个参数（b）。<span class="token number">0</span> <span class="token operator">+</span> <span class="token number">4</span>得到<span class="token number">4</span>，它成了新的累积值。然后再用累积值和流中下一个元素<span class="token number">5</span>调用Lambda，产生新的累积值<span class="token number">9</span>。接下来，再用累积值和下一个元素<span class="token number">3</span>调用Lambda，得到<span class="token number">12</span>。最后，用<span class="token number">12</span>和流中最后一个元素<span class="token number">9</span>调用Lambda，得到最终结果<span class="token number">21</span>。\n</code></pre>\n<h4 id="collect-%E6%90%9C%E9%9B%86">collect 搜集<a class="anchor" href="#collect-%E6%90%9C%E9%9B%86">§</a></h4>\n<ul>\n<li>collect是一个终端操作，它接受的参数是将流中元素累积到汇总结果的各种方式（称为收集器) ,用于给stream中元素做汇总的方法</li>\n<li>具体使用方法在代码里面</li>\n</ul>'
        } }),
    'head': null,
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/index.js", type: "module" })),
    'contentTitle': React.createElement("h1", { key: "0" }, "java8 \u65B0\u7279\u6027\u6559\u7A0B"),
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<blockquote>\n<p>代码地址:<a href="https://github.com/creedzwg/java8_action.git">https://github.com/creedzwg/java8_action.git</a></p>\n</blockquote>\n<h2 id="%E8%AE%B2%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">讲解的新特性<a class="anchor" href="#%E8%AE%B2%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">§</a></h2>\n<ul>\n<li>lambda表达式</li>\n<li>函数式接口</li>\n<li>stream API</li>\n</ul>\n<h2 id="lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">lambda 表达式<a class="anchor" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">§</a></h2>\n<h3 id="%E4%BB%80%E4%B9%88%E6%98%AFlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">什么是lambda表达式<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AFlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">§</a></h3>\n<ul>\n<li>lambda表达式,我们可以把它看做是可传递的匿名函数:它没有名称,但他有参数列表,函数主体,返回类型,还有一个可以抛出的异常列表,它允许把函数作为一个方法的参数进行传递</li>\n</ul>\n<h3 id="lambda-%E7%9A%84%E8%AF%AD%E6%B3%95">lambda 的语法<a class="anchor" href="#lambda-%E7%9A%84%E8%AF%AD%E6%B3%95">§</a></h3>\n<ul>\n<li>(parameters) -&gt; expression</li>\n<li>(parameters) -&gt; {statements;}</li>\n</ul>\n<p><strong>例子:</strong></p>\n<pre class="language-autoit"><code class="language-autoit"> <span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n \n <span class="token punctuation">(</span>Apple a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">150</span>\n \n<span class="token punctuation">(</span>int x<span class="token punctuation">,</span> int y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> {\nSystem<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result:"</span><span class="token punctuation">)</span><span class="token comment">;</span>\nSystem<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token comment">;</span>\n}\n\n<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">42</span>\n\n<span class="token punctuation">(</span>Apple a1<span class="token punctuation">,</span> Apple a2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a1<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a2<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n\n</code></pre>\n<p>Lambda表达式其实是为FunctionalInterface(函数式接口)提供服务的\n函数式接口的定义是接口内只有一个抽象方法,接口现在还可以有默认方法,(即在类没有对方法进行实现时，\n其主体为方法提供默认实现的方法)</p>\n<p>可以用<strong>4个</strong>接口来统一定义所有使用lambada表达式的行为</p>\n<pre class="language-autoit"><code class="language-autoit">\n<span class="token variable">@FunctionalInterface</span>\npublic interface Function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> {\n\n    R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token comment">;</span>\n\n}\n\nFunction 接口<span class="token punctuation">,</span>有一个apply方法<span class="token punctuation">,</span>这表示接受一个参数的类型<span class="token punctuation">,</span>并返回另外一个参数的类型\n\n\n<span class="token variable">@FunctionalInterface</span>\npublic interface Consumer<span class="token operator">&lt;</span>T<span class="token operator">></span> {\n\n\n    void <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token comment">;</span>\n}\n\nConsumer接口<span class="token punctuation">,</span>有一个accept方法<span class="token punctuation">,</span>他接受一个参数<span class="token punctuation">,</span>没有任何返回值<span class="token punctuation">,</span>可以做一些处理工作\n\n<span class="token variable">@FunctionalInterface</span>\npublic interface Predicate<span class="token operator">&lt;</span>T<span class="token operator">></span> {\n\n\n    boolean <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token comment">;</span>\n}\n\nPredicate接口<span class="token punctuation">,</span>判断接口<span class="token punctuation">,</span>有一个test方法<span class="token punctuation">,</span>接受一个参数<span class="token punctuation">,</span>返回boolean值\n\n<span class="token variable">@FunctionalInterface</span>\npublic interface Supplier<span class="token operator">&lt;</span>T<span class="token operator">></span> {\n\n    T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\n}\n\nSupplier接口 <span class="token punctuation">,</span>提供者接口<span class="token punctuation">,</span>有一个get方法<span class="token punctuation">,</span>无参数<span class="token punctuation">,</span>有返回值\n\n\n\n\n</code></pre>\n<p>这4个接口只是4个基本接口,还会有许多函数式接口对这些进行扩展,变种,就不详细一一介绍了</p>\n<h3 id="%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%BF%AB%E6%8D%B7%E5%86%99%E6%B3%95"><strong>方法引用,Lambda表达式的另外一种快捷写法</strong><a class="anchor" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%BF%AB%E6%8D%B7%E5%86%99%E6%B3%95">§</a></h3>\n<ul>\n<li>方法引用让你可以重复的使用现有的方法定义,并像lambda一样传递它们,在某些情况下比起lambda表达式,它们似乎更易读,感觉也更自然\n-方法引用可以被看做仅仅调用特定方法的Lambda的一种快捷方式,换句话说,方法引用就是对Lambda表达式的一种简便写法,使用方法引用可能会提高代码的可读性</li>\n</ul>\n<h5 id="%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">方法引用的工作方式<a class="anchor" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">§</a></h5>\n<ul>\n<li>当你需要使用方法引用的时候,目标引用放在分隔符::前,方法的名称放在后面。例如Apple:getWeight 就是引用了Apple类中定义的方法getWeight ,这个就是 (Apple a) -&gt; a.getWeight()的快捷写法,可以把方法引用看做是仅仅针对涉及单一方法的Lambda的语法糖,因为你表达同样的事情要写的代码就更少了。</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit"><span class="token punctuation">(</span>Apple a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                   Apple<span class="token punctuation">:</span><span class="token punctuation">:</span>getWeight\n<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dumpStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>dumpStack\n<span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>                 String<span class="token punctuation">:</span><span class="token punctuation">:</span>substring\n<span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">:</span><span class="token punctuation">:</span>println\n</code></pre>\n<p>####方法引用的分类</p>\n<ol>\n<li>指向静态方法的方法引用(例如Integer.parseInt方法,可以写作Integer::parseInt)</li>\n</ol>\n<p>Lambda: (args) -&gt; ClassName.staticMethod(args)\n方法引用: ClassName:: staticMethod</p>\n<ol start="2">\n<li>指向任意类型实例方法的方法引用(例如String 的length 方法， 写作String::length)\n类似于String::length的第二种方法引用的思想就是你在引用一个对象的方法，而这个对象本身是Lambda的一个参数\nLambda: (arg1,rest) -&gt;arg1.instanceMethod(rest)\n方法引用: ClassName::instanceMethod</li>\n<li>指向现有对象的实例方法的方法引用(假设你有一个局部变量a 用来存放 A类型的对象,它有个示例方法getValue,那么就可以写成a::getValue)\n第三种方法引用指的是，你在Lambda中调用一个已经存在的外部对象中的方法\nSupplier<Integer> s =()-&gt;a.getWeight()\nLambda: (args) -&gt;instance.instanceMethod(args)\n方法引用: instance::instanceMethod</li>\n</ol>\n<h4 id="%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90">具体例子<a class="anchor" href="#%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90">§</a></h4>\n<ul>\n<li>对一个字符串的List进行排序,List的sort方法需要一个Comparator实现作为参数,Comparator描述了一个具有(T,T)-&gt;int签名的函数描述符。你可以利用String类的CompareTo方法来定义一个lambda表达式.</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">List<span class="token operator">&lt;</span>String<span class="token operator">></span> str <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token comment">;</span>\nstr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">;</span>\n\n可以修改成str<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span>compareTo<span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8">构造函数引用<a class="anchor" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8">§</a></h4>\n<ul>\n<li>对于一个现有的构造函数,你可以利用它的名称和关键字new 来创建它的一个引用</li>\n</ul>\n<p><code>Supplier&lt;Apple&gt; c1=Apple::new 等价于 Supplier&lt;Apple&gt; c1=()-&gt;new Apple()</code></p>\n<h4 id="lambda%E6%80%BB%E7%BB%93">lambda总结<a class="anchor" href="#lambda%E6%80%BB%E7%BB%93">§</a></h4>\n<ul>\n<li>Lambda表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回\n类型，可能还有一个可以抛出的异常的列表。</li>\n<li>Lambda表达式让你可以简洁地传递代码。</li>\n<li>函数式接口就是仅仅声明了一个抽象方法的接口。</li>\n<li>只有在接受函数式接口的地方才可以使用Lambda表达式。</li>\n<li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式\n作为函数式接口的一个实例。</li>\n<li>Java 8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate\n<T>、Function&lt;T,R&gt;、Supplier<T>、Consumer<T>和BinaryOperator<T>，如表\n3-2所述。</li>\n<li>方法引用让你重复使用现有的方法实现并直接传递它们。</li>\n<li>Comparator、Predicate和Function等函数式接口都有几个可以用来结合Lambda表达\n式的默认方法</li>\n</ul>\n<h3 id="stream-%E6%B5%81">Stream 流<a class="anchor" href="#stream-%E6%B5%81">§</a></h3>\n<h4 id="%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5">流的概念<a class="anchor" href="#%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5">§</a></h4>\n<ul>\n<li>流是java API的新成员,它允许你以声明性方式处理数据集合(通过查询语句来表达,而不是临时编写一个实现),同时可以并行处理,提高处理效率</li>\n<li>Stream 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询。也可以使用Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式</li>\n</ul>\n<h4 id="stream%E7%9A%84%E7%94%A8%E6%B3%95">Stream的用法<a class="anchor" href="#stream%E7%9A%84%E7%94%A8%E6%B3%95">§</a></h4>\n<ul>\n<li>流的使用一般包括三件事:</li>\n</ul>\n<ol>\n<li>一个数据源来执行一个查询,(创建stream)</li>\n<li>一个中间操作链,形成一条流的流水线(中间操作)</li>\n<li>一个终端操作,执行流水线,并能生成结果(终止操作)</li>\n</ol>\n<ul>\n<li>创建流的方式</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit"><span class="token operator">/</span><span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span> 可以通过集合顶级集合Collection的默认<span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>或者parallelStream方法\nList<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token operator">=</span>new ArrayList<span class="token operator">&lt;></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\nStream<span class="token operator">&lt;</span>String<span class="token operator">></span> stream1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\n\n<span class="token operator">/</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">.</span>通过Arrays中的静态方法<span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 获取数组流\nDish<span class="token punctuation">[</span><span class="token punctuation">]</span> dishs<span class="token operator">=</span>new  Dish<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token comment">;</span>\nStream<span class="token operator">&lt;</span>Dish<span class="token operator">></span> stream2 <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>dishs<span class="token punctuation">)</span><span class="token comment">;</span>\n<span class="token operator">/</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">.</span> 通过Stream类中的静态方法<span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nStream<span class="token operator">&lt;</span>String<span class="token operator">></span> stream3 <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token string">"bb"</span><span class="token punctuation">,</span> <span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token comment">;</span>\n<span class="token operator">/</span><span class="token operator">/</span>创建无限流\nStream<span class="token operator">&lt;</span>Integer<span class="token operator">></span> iterate <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">;</span>\niterate<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">:</span><span class="token punctuation">:</span>println<span class="token punctuation">)</span><span class="token comment">;</span>\n\n<span class="token operator">/</span><span class="token operator">/</span>通过Stream的generate方式<span class="token punctuation">,</span>也是无限流\n\nStream<span class="token operator">&lt;</span>Double<span class="token operator">></span> generate <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span>Math<span class="token punctuation">:</span><span class="token punctuation">:</span>random<span class="token punctuation">)</span><span class="token comment">;</span>\ngenerate<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">:</span><span class="token punctuation">:</span>println<span class="token punctuation">)</span><span class="token comment">;</span>\n</code></pre>\n<ul>\n<li>中间操作</li>\n</ul>\n<ol>\n<li>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！\n而在终止操作时一次性全部处理，称为“惰性求值&quot;</li>\n</ol>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>类型</th>\n<th>返回类型</th>\n<th>操作参数</th>\n<th>函数描述符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>filter</td>\n<td>中间</td>\n<td>Stream<T></td>\n<td>Predicate<T></td>\n<td>T -&gt; Boolean</td>\n</tr>\n<tr>\n<td>map</td>\n<td>中间操作</td>\n<td>Stream<R></td>\n<td>Function&lt;T,R&gt;</td>\n<td>T -&gt; R</td>\n</tr>\n<tr>\n<td>limit</td>\n<td>中间操作</td>\n<td>Stream<T></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip</td>\n<td>中间操作</td>\n<td>Stream<T></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sorted</td>\n<td>中间操作</td>\n<td>Stream<T></td>\n<td>Comparator<T></td>\n<td>(T,T) -&gt;Int</td>\n</tr>\n<tr>\n<td>distinct</td>\n<td>中间操作</td>\n<td>Stream<T></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>foreach</td>\n<td>终端</td>\n<td>消费流中的每个元素并对其应用Lambda,操作返回void</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>count</td>\n<td></td>\n<td>终端</td>\n<td>返回流中元素的个数,这一顿操作返回Long</td>\n<td></td>\n</tr>\n<tr>\n<td>collect</td>\n<td></td>\n<td>终端</td>\n<td>把流规约成一个集合,比如List,Map甚至是Integer</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="stream-api-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F">stream API 的操作方式<a class="anchor" href="#stream-api-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F">§</a></h4>\n<h4 id="%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C">中间操作<a class="anchor" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C">§</a></h4>\n<h5 id="%E7%AD%9B%E9%80%89%E5%92%8C%E5%88%87%E7%89%87">筛选和切片<a class="anchor" href="#%E7%AD%9B%E9%80%89%E5%92%8C%E5%88%87%E7%89%87">§</a></h5>\n<p>用predicate,筛选出不同的元素,忽略流中的的头几个元素,获奖流切断至指定长度</p>\n<ul>\n<li>filter方法。该操作会接受一个Predicate谓词（一个返回\nboolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>isVegetarian<span class="token punctuation">)</span>\n</code></pre>\n<ul>\n<li>distinct的方法，它会返回一个元素各异（根据流所生成元素的\nhashCode和equals方法实现）的流</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">;</span>\nnumbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre>\n<ul>\n<li>limit(n)方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递\n给limit。如果流是有序的，则最多会返回前n个元素;也可以用在无序流上，比如源是一个Set。这种情况下，limit的结果不会以任何顺序排列</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>d <span class="token operator">-</span><span class="token operator">></span> d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre>\n<ul>\n<li>skip(n)方法 ,流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一\n个空流。</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>d <span class="token operator">-</span><span class="token operator">></span> d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n</code></pre>\n<h5 id="%E6%98%A0%E5%B0%84"><strong>映射</strong><a class="anchor" href="#%E6%98%A0%E5%B0%84">§</a></h5>\n<p>一个非常常见的数据处理套路就是从某些对象中选择信息。比如在SQL里，你可以从表中选择一列。Stream API也通过map和flatMap方法提供了类似的工具</p>\n<ul>\n<li>map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素</li>\n</ul>\n<p>-flatMap他会接受一个参数作为函数,将流中每个值都换成另一个流,最后再将所有流拼成另外一个流</p>\n<pre class="language-autoit"><code class="language-autoit">menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>getName<span class="token punctuation">)</span>\n\n</code></pre>\n<h5 id="%E6%8E%92%E5%BA%8F">排序<a class="anchor" href="#%E6%8E%92%E5%BA%8F">§</a></h5>\n<ul>\n<li>排序分为自然排序(本身实现Cpmparaable 接口,实现了CompareTo方法)</li>\n<li>定制排序,通过Comparator接口实现</li>\n</ul>\n<h4 id="%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C">终止操作<a class="anchor" href="#%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C">§</a></h4>\n<h5 id="%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8C%B9%E9%85%8D">查找和匹配<a class="anchor" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8C%B9%E9%85%8D">§</a></h5>\n<ul>\n<li>另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性,\nStreamAPI通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的具</li>\n</ul>\n<h5 id="%E6%A3%80%E6%9F%A5predicate%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E8%87%B3%E5%B0%91%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">检查Predicate谓词是否至少匹配一个元素<a class="anchor" href="#%E6%A3%80%E6%9F%A5predicate%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E8%87%B3%E5%B0%91%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">§</a></h5>\n<pre class="language-autoit"><code class="language-autoit">此操作用来查看菜单中是否有素食可以选择\n<span class="token function">if</span><span class="token punctuation">(</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>isVegetarian<span class="token punctuation">)</span><span class="token punctuation">)</span>{\nSystem<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有素食"</span><span class="token punctuation">)</span><span class="token comment">;</span>\n}\nanyMatch方法返回一个boolean，因此是一个终端操作 \n</code></pre>\n<h5 id="%E6%A3%80%E6%9F%A5%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0">检查谓词是否匹配所有元素<a class="anchor" href="#%E6%A3%80%E6%9F%A5%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0">§</a></h5>\n<ul>\n<li>allMatch方法的工作原理和anyMatch类似，但它会看看流中的元素是否都能匹配给定的谓词</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">是否菜单里面所有的菜的热量都小于<span class="token number">1000</span>卡路里\nboolean  status<span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span>d <span class="token operator">-</span><span class="token operator">></span> d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment">;</span>\n</code></pre>\n<h5 id="%E6%A3%80%E6%9F%A5%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E6%B2%A1%E6%9C%89%E5%85%83%E7%B4%A0%E8%B7%9F%E4%BB%96%E5%8C%B9%E9%85%8D">检查谓词是否没有元素跟他匹配<a class="anchor" href="#%E6%A3%80%E6%9F%A5%E8%B0%93%E8%AF%8D%E6%98%AF%E5%90%A6%E6%B2%A1%E6%9C%89%E5%85%83%E7%B4%A0%E8%B7%9F%E4%BB%96%E5%8C%B9%E9%85%8D">§</a></h5>\n<ul>\n<li>noneMatch()跟allMatch()相反,它可以确保流中没有任何元素与给定的谓词匹配</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">是否菜单里面所有的菜的热量都小于<span class="token number">1000</span>卡路里\nmenu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span>d <span class="token operator">-</span><span class="token operator">></span> d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E6%9F%A5%E6%89%BE%E4%BB%BB%E6%84%8F%E5%85%83%E7%B4%A0">查找任意元素<a class="anchor" href="#%E6%9F%A5%E6%89%BE%E4%BB%BB%E6%84%8F%E5%85%83%E7%B4%A0">§</a></h4>\n<ul>\n<li>findAny方法将返回当前流中的任意元素</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit"> Optional<span class="token operator">&lt;</span>Dish<span class="token operator">></span> dish <span class="token operator">=</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>isVegetarian<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\n\n可以看出<span class="token punctuation">,</span>返回的是一个Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">,</span>他是一个容器类<span class="token punctuation">,</span>代表着一个值存在或者不存在<span class="token punctuation">,</span>\n\n在上面的代码中，findAny可能什么元素都没找到。Java <span class="token number">8</span>的库设计人员引入了Optional<span class="token operator">&lt;</span>T<span class="token operator">></span>，这样就不用返回众所周知容易出问题的<span class="token keyword">null</span>了。\n\n\n</code></pre>\n<h4 id="%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">查找第一个元素<a class="anchor" href="#%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">§</a></h4>\n<ul>\n<li>findFirst方法返回流中的第一个数据</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">Optional<span class="token operator">&lt;</span>Dish<span class="token operator">></span> dish <span class="token operator">=</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Dish<span class="token punctuation">:</span><span class="token punctuation">:</span>isVegetarian<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">;</span>\n</code></pre>\n<h4 id="%E8%A7%84%E7%BA%A6">规约<a class="anchor" href="#%E8%A7%84%E7%BA%A6">§</a></h4>\n<ul>\n<li>之前讲的终端操作都是一个boolean或者void ,或者Optional对象,也有使用collect来将\n流中的所有元素组合成一个List,</li>\n<li>使用规约可以把流中的元素组合起来,然后得到一个值。</li>\n</ul>\n<h4 id="%E5%85%83%E7%B4%A0%E6%B1%82%E5%92%8C">元素求和<a class="anchor" href="#%E5%85%83%E7%B4%A0%E6%B1%82%E5%92%8C">§</a></h4>\n<pre class="language-autoit"><code class="language-autoit"><span class="token operator">-</span> reduce\n对传统的数字列表的元素进行求和<span class="token punctuation">,</span>我们可能会这么做\nint sum <span class="token operator">=</span> <span class="token number">0</span><span class="token comment">;</span>\nint<span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token operator">=</span>{<span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span>}<span class="token comment">;</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span>int x <span class="token punctuation">:</span> numbers<span class="token punctuation">)</span> {\nsum <span class="token operator">+=</span> x<span class="token comment">;</span>\n}\nnumbers中的每个元素都用加法运算符反复迭代来得到结果。通过反复使用加法，你把一个\n数字列表归约成了一个数字。这段代码中有两个参数：\n<span class="token number">1</span> 总和变量的初始值，在这里是<span class="token number">0</span>；\n<span class="token number">2</span> 将列表中所有元素结合在一起的操作，在这里是<span class="token operator">+</span>\n\n这种就可以使用reduce操作来灵活完成\nint sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token comment">;</span>\nreduce 接受两个参数\n\n<span class="token number">1</span><span class="token punctuation">.</span> 一个初始值<span class="token punctuation">,</span>这个是<span class="token number">0</span>\n<span class="token number">2</span><span class="token punctuation">.</span> 一个BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span>来将两个元素结合起来产生一个新值，这里我们用的是\nlambda <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b。\n\n首先，<span class="token number">0</span>作为Lambda（a）的第一个参数，从流中获得<span class="token number">4</span>作为第二个参数（b）。<span class="token number">0</span> <span class="token operator">+</span> <span class="token number">4</span>得到<span class="token number">4</span>，它成了新的累积值。然后再用累积值和流中下一个元素<span class="token number">5</span>调用Lambda，产生新的累积值<span class="token number">9</span>。接下来，再用累积值和下一个元素<span class="token number">3</span>调用Lambda，得到<span class="token number">12</span>。最后，用<span class="token number">12</span>和流中最后一个元素<span class="token number">9</span>调用Lambda，得到最终结果<span class="token number">21</span>。\n</code></pre>\n<h4 id="collect-%E6%90%9C%E9%9B%86">collect 搜集<a class="anchor" href="#collect-%E6%90%9C%E9%9B%86">§</a></h4>\n<ul>\n<li>collect是一个终端操作，它接受的参数是将流中元素累积到汇总结果的各种方式（称为收集器) ,用于给stream中元素做汇总的方法</li>\n<li>具体使用方法在代码里面</li>\n</ul>'
        } }),
    'toc': React.createElement("aside", { dangerouslySetInnerHTML: {
            __html: '<nav class="toc"><ol><li><a href="#%E8%AE%B2%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">讲解的新特性</a></li><li><a href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">lambda 表达式</a><ol><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">什么是lambda表达式</a></li><li><a href="#lambda-%E7%9A%84%E8%AF%AD%E6%B3%95">lambda 的语法</a></li><li><a href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%BF%AB%E6%8D%B7%E5%86%99%E6%B3%95">方法引用,Lambda表达式的另外一种快捷写法</a><ol></ol></li><li><a href="#stream-%E6%B5%81">Stream 流</a><ol></ol></li></ol></li></ol></nav>'
        } }),
    'author': "zhangwengang",
    'contributors': [
        "zhangwengang"
    ],
    'date': "2019-05-23T00:00:00.000Z",
    'updated': "2021-02-23T06:35:38.000Z",
    'excerpt': "讲解的新特性 - lambda表达式 - 函数式接口 - stream API lambda 表达式 什么是lambda表达式 - lambda表达式,我们可以把它看做是可传递的匿名函数:它没有名称,但他有参数列表,函数主体,返回类型,还有一个可以抛出的异常列表,它...",
    'cover': undefined,
    'categories': [
        "编程世界"
    ],
    'tags': [
        "java8"
    ],
    'blog': {
        "isPost": true,
        "posts": [
            {
                "pagePath": "posts/https.md",
                "title": "一次https请求的流程",
                "link": "posts/https.html",
                "date": "2020-12-04T00:00:00.000Z",
                "updated": "2020-12-23T08:10:12.000Z",
                "author": "zhangwengang",
                "contributors": [
                    "zhangwengang"
                ],
                "categories": [
                    "一天一道面试题"
                ],
                "tags": [
                    "http",
                    "https"
                ],
                "excerpt": "相关名词解释 https - 首先说一下https,https全文名称(hyper text transfer protocol over SecureSocket layer) ,字面意思是在ssl基础上的 http协议,在传统http的基础上,通过加密传输,身份认证(ssl)保证了传输过程的安全性,htt...",
                "cover": "../assets/https/2020-12-07_17-29-52.png"
            },
            {
                "pagePath": "posts/volatile浅析.md",
                "title": "volatile浅析",
                "link": "posts/volatile浅析.html",
                "date": "2020-10-11T00:00:00.000Z",
                "updated": null,
                "author": "zhangwengang",
                "contributors": [
                    "zhangwengang"
                ],
                "categories": [
                    "编程世界"
                ],
                "tags": [
                    "volatile",
                    "并发编程"
                ],
                "excerpt": "简介 1. volatile 关键是用来修饰静态变量和实例变量的,对于方法参数,局部变量和实例常量和类常量都不能修饰 2. volatile修饰的类变量和实例变量能保证两次语义 - :保证了不同线程对共享变量操作时的可见性,即一个线程对变量的...",
                "cover": "../assets/volatile/jmm.jpg"
            },
            {
                "pagePath": "posts/zookeeper.md",
                "title": "zookeeper 入门",
                "link": "posts/zookeeper.html",
                "date": "2020-07-05T00:00:00.000Z",
                "updated": null,
                "author": "zhangwengang",
                "contributors": [
                    "zhangwengang"
                ],
                "categories": [
                    "编程世界"
                ],
                "tags": [
                    "zookeeper",
                    "zab"
                ],
                "excerpt": "zookeeper是什么? 官网的介绍:zookeeper是一个开放源代码的分布式协调服务,由雅虎创建.是google chubby的开源实现,她是一个典型的分布式数据一致性的解决方案,分布式系统可以基于它来实现诸如数据发布/订阅,负载均衡,命名服务,...",
                "cover": "../assets/zookeeper/zk%20node.jpg"
            },
            {
                "pagePath": "posts/apollo_hello_world.md",
                "title": "apollo 入门",
                "link": "posts/apollo_hello_world.html",
                "date": "2019-09-12T00:00:00.000Z",
                "updated": null,
                "author": "zhangwengang",
                "contributors": [
                    "zhangwengang"
                ],
                "categories": [
                    "编程世界"
                ],
                "tags": [
                    "apollo",
                    "配置中心"
                ],
                "excerpt": "apollo的功能亮点 1. 统一管理不同环境,不同集群的配置 2. 配置修改实时生效(热发布) 3. 版本发布管理 4. 灰度发布 5. 有权限管理 6. 文档完善 apollo文档 apollo基础模型 1. 用户在配置中心对配置进行修改并发布 2. 配置中心会...",
                "cover": "../assets/apollo/610A4B1D-2D93-4759-A79F-E53C09D529ED.png"
            },
            {
                "pagePath": "posts/java8_new_feature.md",
                "title": "java8 新特性教程",
                "link": "posts/java8_new_feature.html",
                "date": "2019-05-23T00:00:00.000Z",
                "updated": "2021-02-23T06:35:38.000Z",
                "author": "zhangwengang",
                "contributors": [
                    "zhangwengang"
                ],
                "categories": [
                    "编程世界"
                ],
                "tags": [
                    "java8"
                ],
                "excerpt": "讲解的新特性 - lambda表达式 - 函数式接口 - stream API lambda 表达式 什么是lambda表达式 - lambda表达式,我们可以把它看做是可传递的匿名函数:它没有名称,但他有参数列表,函数主体,返回类型,还有一个可以抛出的异常列表,它..."
            },
            {
                "pagePath": "posts/jvm hello world.md",
                "title": "jvm",
                "link": "posts/jvm hello world.html",
                "date": "2018-10-11T00:00:00.000Z",
                "updated": null,
                "author": "zhangwengang",
                "contributors": [
                    "zhangwengang"
                ],
                "categories": [
                    "编程世界"
                ],
                "tags": [
                    "jvm",
                    "并发编程"
                ],
                "excerpt": "jvm 的生命周期 虚拟机的启动 1：java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class)来完成的，这个类是由虚拟机的具体事项指定的 虚拟机的执行 - 一个运行中的Java虚拟机有着一个清...",
                "cover": "https://img.hacpai.com/file/2020/03/20200315160049-d756f8e7.png"
            }
        ],
        "categories": [
            {
                "name": "编程世界",
                "count": 5
            },
            {
                "name": "一天一道面试题",
                "count": 1
            }
        ],
        "tags": [
            {
                "name": "并发编程",
                "count": 2
            },
            {
                "name": "apollo",
                "count": 1
            },
            {
                "name": "http",
                "count": 1
            },
            {
                "name": "https",
                "count": 1
            },
            {
                "name": "java8",
                "count": 1
            },
            {
                "name": "jvm",
                "count": 1
            },
            {
                "name": "volatile",
                "count": 1
            },
            {
                "name": "zab",
                "count": 1
            },
            {
                "name": "zookeeper",
                "count": 1
            },
            {
                "name": "配置中心",
                "count": 1
            }
        ]
    }
};
